// Copyright (c) 2024 Matthijs Keuper
// SPDX-License-Identifier: MIT
// THIS SECTION GENERATED BY Claude - Lightweight GLSL syntax highlighter
// Based on Prism.js patterns but simplified for just GLSL

/**
 * Simple GLSL syntax highlighter for textarea overlays
 * Highlights: keywords, types, functions, comments, strings, numbers
 */
export class GLSLHighlighter {
    constructor() {
        // GLSL keywords and built-ins
        this.patterns = {
            comment: /\/\*[\s\S]*?\*\/|\/\/.*$/gm,
            string: /"(?:[^"\\]|\\.)*"/g,
            number: /\b\d*\.?\d+(?:[eE][+-]?\d+)?[fF]?\b/g,
            keyword: /\b(?:U|M|if|else|for|while|do|break|continue|return|discard|struct|uniform|attribute|varying|in|out|inout|const|precision|highp|mediump|lowp|layout|location)\b/g,
            type: /\b(?:F|V|W|X|S2|void|bool|int|uint|float|double|vec[234]|dvec[234]|bvec[234]|ivec[234]|uvec[234]|mat[234]|mat[234]x[234]|dmat[234]|dmat[234]x[234]|sampler[12]D|samplerCube|sampler[12]DArray|samplerBuffer|sampler2DMS|sampler2DMSArray|samplerCubeArray|sampler[12]DShadow|samplerCubeShadow|sampler[12]DArrayShadow|samplerCubeArrayShadow|isampler[12]D|isamplerCube|isampler[12]DArray|isamplerBuffer|isampler2DMS|isampler2DMSArray|isamplerCubeArray|usampler[12]D|usamplerCube|usampler[12]DArray|usamplerBuffer|usampler2DMS|usampler2DMSArray|usamplerCubeArray|image[12]D|imageCube|image[12]DArray|imageBuffer|image2DMS|image2DMSArray|imageCubeArray|iimage[12]D|iimageCube|iimage[12]DArray|iimageBuffer|iimage2DMS|iimage2DMSArray|iimageCubeArray|uimage[12]D|uimageCube|uimage[12]DArray|uimageBuffer|uimage2DMS|uimage2DMSArray|uimageCubeArray)\b/g,
            builtin: /\b(?:T|L|N|gl_Position|gl_FragColor|gl_FragCoord|gl_VertexID|gl_InstanceID|texture|texture2D|textureCube|length|normalize|dot|cross|reflect|refract|mix|step|smoothstep|clamp|min|max|abs|sign|floor|ceil|fract|mod|sqrt|pow|exp|log|sin|cos|tan|asin|acos|atan|degrees|radians|distance|faceforward|any|all|equal|notEqual|lessThan|lessThanEqual|greaterThan|greaterThanEqual)\b/g
        };
        
        this.colors = {
            comment: '#6a9955',
            string: '#ce9178', 
            number: '#b5cea8',
            keyword: '#569cd6',
            type: '#4ec9b0',
            builtin: '#dcdcaa'
        };
        
        // CSS class prefix for highlighting tokens
        this.classPrefix = 'token-';
    }
    
    /**
     * Highlight GLSL code and return HTML with CSS classes
     * @param {string} code - Raw GLSL code
     * @returns {string} - HTML with CSS class-based syntax highlighting
     */
    highlight(code) {
        // THIS SECTION GENERATED BY Claude - CSS class-based highlighting
        const tokens = this.tokenize(code);
        return tokens.map(token => {
            if (token.type === 'text') {
                return this.escapeHtml(token.value);
            } else {
                return `<span class="glsl-${token.type}">${this.escapeHtml(token.value)}</span>`;
            }
        }).join('');
    }
    
    /**
     * Generate CSS styles for syntax highlighting
     * @returns {string} - CSS stylesheet text
     */
    generateCSS() {
        const baseStyle = '.glsl-highlight-overlay { color: var(--in-fg, #d4d4d4); }';
        const tokenStyles = Object.entries(this.colors).map(([type, color]) => 
            `.glsl-${type} { color: ${color}; }`
        ).join('\n');
        return baseStyle + '\n' + tokenStyles;
    }
    
    /**
     * Inject CSS styles into document head
     */
    injectCSS() {
        const styleId = 'glsl-highlighter-styles';
        
        // Remove existing styles if present
        const existing = document.getElementById(styleId);
        if (existing) {
            existing.remove();
        }
        
        // Create and inject new styles
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = this.generateCSS();
        document.head.appendChild(style);
    }
    
    /**
     * Tokenize code into syntax tokens
     * THIS SECTION GENERATED BY Claude
     */
    tokenize(code) {
        const tokens = [];
        let position = 0;
        
        while (position < code.length) {
            let matched = false;
            
            // Try each pattern
            for (const [type, pattern] of Object.entries(this.patterns)) {
                pattern.lastIndex = position;
                const match = pattern.exec(code);
                
                if (match && match.index === position) {
                    // Add any text before this match
                    if (match.index > position) {
                        tokens.push({
                            type: 'text',
                            value: code.slice(position, match.index)
                        });
                    }
                    
                    // Add the matched token
                    tokens.push({
                        type: type,
                        value: match[0]
                    });
                    
                    position = match.index + match[0].length;
                    matched = true;
                    break;
                }
            }
            
            // If no pattern matched, add one character as text
            if (!matched) {
                const nextTokenStart = this.findNextToken(code, position);
                const textLength = nextTokenStart > position ? nextTokenStart - position : 1;
                
                tokens.push({
                    type: 'text',
                    value: code.slice(position, position + textLength)
                });
                
                position += textLength;
            }
        }
        
        return tokens;
    }
    
    /**
     * Find the start of the next token
     * THIS SECTION GENERATED BY Claude
     */
    findNextToken(code, fromPosition) {
        let nextPos = code.length;
        
        for (const pattern of Object.values(this.patterns)) {
            pattern.lastIndex = fromPosition;
            const match = pattern.exec(code);
            if (match && match.index < nextPos) {
                nextPos = match.index;
            }
        }
        
        return nextPos;
    }
    
    /**
     * Escape HTML entities
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    /**
     * Create a syntax-highlighted overlay for a textarea
     * @param {HTMLTextAreaElement} textarea - Target textarea
     * @returns {HTMLElement} - Overlay element
     */
    createOverlay(textarea) {
        const overlay = document.createElement('div');
        overlay.className = 'glsl-highlight-overlay';
        
        // Copy textarea styles
        const computedStyle = getComputedStyle(textarea);
        Object.assign(overlay.style, {
            position: 'absolute',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            padding: computedStyle.padding,
            margin: computedStyle.margin,
            border: 'none',
            font: computedStyle.font,
            fontSize: computedStyle.fontSize,
            fontFamily: computedStyle.fontFamily,
            lineHeight: computedStyle.lineHeight,
            whiteSpace: 'pre-wrap',
            wordWrap: computedStyle.wordWrap,
            overflow: 'hidden',
            pointerEvents: 'none',
            color: 'var(--in-fg)', // THIS SECTION GENERATED BY Claude - Use Tweakpane's input foreground color
            background: 'transparent',
            zIndex: '1'
        });
        
        return overlay;
    }
    
    /**
     * Update overlay content with highlighted code
     */
    updateOverlay(overlay, code) {
        overlay.innerHTML = this.highlight(code);
    }
}
