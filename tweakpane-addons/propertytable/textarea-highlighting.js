// THIS SECTION GENERATED BY Claude - Textarea syntax highlighting system
// Handles setup and management of syntax highlighting overlays for textareas

import { GLSLHighlighter } from './prism-glsl.js';

/**
 * Apply styling and optional syntax highlighting to a textarea
 * @param {HTMLTextAreaElement} textarea - The textarea element to style
 * @param {Object} options - Configuration options
 * @param {boolean} options.wordwrap - Enable word wrapping
 * @param {string} options.highlighting - Type of syntax highlighting ('glsl', etc.)
 */
export function setTextareaStyle(textarea, options = {}) {
    let wordwrap = options.wordwrap;
    let highlighting = options.highlighting || null;

    // Basic textarea styling
    textarea.readOnly = false;
    textarea.style.cursor = 'text';
    textarea.style.backgroundColor = 'var(--in-bg)';
    
    // Word wrap settings
    if (wordwrap) {
        textarea.style.whiteSpace = 'pre-wrap'; // Preserves whitespace and line breaks but allows wrapping
        textarea.style.wordWrap = 'break-word'; // Break long words
        textarea.style.overflowWrap = 'break-word'; // Modern alternative
    } else {
        textarea.style.whiteSpace = 'pre'; // Preserves whitespace but no wrapping
        textarea.style.wordWrap = 'normal';
        textarea.style.overflowWrap = 'normal';
        textarea.style.overflowX = 'auto'; // Allow horizontal scroll when no wrap
    }
    
    // Font settings to match Tweakpane inputs
    textarea.style.fontFamily = 'inherit';
    textarea.style.fontSize = 'inherit';
    textarea.style.fontWeight = 'inherit';
    
    // Setup syntax highlighting if specified
    if (highlighting) {
        textarea.setAttribute('data-highlighting', highlighting);
        if (highlighting === 'glsl') {
            setupGLSLHighlighting(textarea);
        }
    }
}

/**
 * Setup GLSL syntax highlighting overlay for a textarea
 * @param {HTMLTextAreaElement} textarea - The textarea to add highlighting to
 */
function setupGLSLHighlighting(textarea) {
    // Inject CSS styles if not already done
    if (!window.glslHighlighter) {
        window.glslHighlighter = new GLSLHighlighter();
        window.glslHighlighter.injectCSS();
    }
    
    // Create overlay container
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.width = '100%';
    container.style.backgroundColor = textarea.style.backgroundColor || 'var(--in-bg)'; // Preserve textarea background
    container.style.borderRadius = textarea.style.borderRadius || 'var(--bld-br)'; // Match Tweakpane styling
    container.style.border = textarea.style.border; // Preserve original border
    container.style.padding = textarea.style.padding; // Preserve original padding
    
    // Create syntax highlighting overlay
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.pointerEvents = 'none';
    
    // Copy text wrapping and font styles exactly from textarea
    const textareaComputedStyle = getComputedStyle(textarea);
    overlay.style.whiteSpace = textareaComputedStyle.whiteSpace;
    overlay.style.wordWrap = textareaComputedStyle.wordWrap;
    overlay.style.overflowWrap = textareaComputedStyle.overflowWrap;
    overlay.style.wordBreak = textareaComputedStyle.wordBreak;
    overlay.style.fontFamily = textareaComputedStyle.fontFamily;
    overlay.style.fontSize = textareaComputedStyle.fontSize;
    overlay.style.fontWeight = textareaComputedStyle.fontWeight;
    overlay.style.lineHeight = textareaComputedStyle.lineHeight;
    overlay.style.letterSpacing = textareaComputedStyle.letterSpacing;
    overlay.style.textAlign = textareaComputedStyle.textAlign;
    overlay.style.padding = '0'; // Remove padding since container handles it
    overlay.style.margin = '0'; // Remove margin since container handles it
    overlay.style.border = 'none'; // Remove border since container handles it
    overlay.style.color = 'var(--in-fg)'; // Use proper text color for base text
    overlay.style.zIndex = '1';
    overlay.style.overflow = 'hidden';
    
    // Make textarea transparent on top but keep caret visible
    textarea.style.position = 'relative';
    textarea.style.zIndex = '2';
    textarea.style.background = 'transparent';
    textarea.style.backgroundColor = 'transparent'; // Ensure background is fully transparent
    textarea.style.color = 'transparent';
    textarea.style.caretColor = 'var(--in-fg)'; // Use input foreground color for caret
    textarea.style.border = 'none'; // Remove border since container now handles it
    textarea.style.outline = 'none'; // Remove outline
    textarea.style.padding = '0'; // Remove padding since container handles it
    textarea.style.margin = '0'; // Remove margin since container handles it
    
    // Ensure caret is visible with multiple fallbacks
    textarea.style.setProperty('caret-color', 'var(--in-fg)', 'important');
    // Add fallback for older browsers or if CSS variable fails
    if (!CSS.supports('caret-color', 'var(--in-fg)')) {
        textarea.style.setProperty('caret-color', '#ffffff', 'important');
    }
    
    // Additional caret visibility fixes
    textarea.style.textShadow = 'none'; // Remove any text shadows that might hide caret
    textarea.style.webkitTextFillColor = 'transparent'; // Webkit-specific transparency
    textarea.addEventListener('focus', () => {
        // Force caret to be visible on focus
        textarea.style.setProperty('caret-color', 'var(--in-fg)', 'important');
    });
    
    // Wrap textarea and add overlay
    const parent = textarea.parentNode;
    parent.insertBefore(container, textarea);
    container.appendChild(overlay);
    container.appendChild(textarea);
    
    // Function to update syntax highlighting with debouncing for performance
    let highlightTimeout;
    function updateHighlighting() {
        clearTimeout(highlightTimeout);
        highlightTimeout = setTimeout(() => {
            overlay.innerHTML = window.glslHighlighter.highlight(textarea.value);
        }, 50); // Debounce for 50ms for better performance
    }
    
    // Function to synchronize scroll position and dimensions
    function syncOverlay() {
        overlay.scrollTop = textarea.scrollTop;
        overlay.scrollLeft = textarea.scrollLeft;
        
        // Ensure overlay dimensions match textarea exactly
        const textareaRect = textarea.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        overlay.style.width = `${textareaRect.width}px`;
        overlay.style.height = `${textareaRect.height}px`;
    }
    
    // Update highlighting on input and scroll events
    textarea.addEventListener('input', updateHighlighting);
    textarea.addEventListener('scroll', syncOverlay);
    textarea.addEventListener('resize', syncOverlay);
    
    // Add ResizeObserver to handle dynamic resizing
    if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
            syncOverlay();
            updateHighlighting(); // Re-highlight on resize as line breaks may change
        });
        resizeObserver.observe(textarea);
        resizeObserver.observe(container);
    }
    
    // Initial highlighting and synchronization
    updateHighlighting();
    syncOverlay();
}

/**
 * Remove syntax highlighting from a textarea and restore normal styling
 * @param {HTMLTextAreaElement} textarea - The textarea to remove highlighting from
 */
export function removeTextareaHighlighting(textarea) {
    const container = textarea.parentNode;
    const overlay = container.querySelector('div[style*="position: absolute"]');
    
    if (overlay && container.style.position === 'relative') {
        // Restore original textarea styling
        textarea.style.position = '';
        textarea.style.zIndex = '';
        textarea.style.background = 'var(--in-bg)';
        textarea.style.color = 'var(--in-fg)';
        textarea.style.caretColor = '';
        
        // Move textarea back to original parent
        const originalParent = container.parentNode;
        originalParent.insertBefore(textarea, container);
        container.remove();
        
        // Remove highlighting attribute
        textarea.removeAttribute('data-highlighting');
    }
}

/**
 * Check if a textarea has syntax highlighting enabled
 * @param {HTMLTextAreaElement} textarea - The textarea to check
 * @returns {boolean} True if highlighting is enabled
 */
export function hasTextareaHighlighting(textarea) {
    return textarea.hasAttribute('data-highlighting');
}

/**
 * Get the highlighting type for a textarea
 * @param {HTMLTextAreaElement} textarea - The textarea to check
 * @returns {string|null} The highlighting type or null if none
 */
export function getTextareaHighlightingType(textarea) {
    return textarea.getAttribute('data-highlighting');
}
